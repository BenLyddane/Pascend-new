"use server";

import { createClient } from "@/utils/supabase/server";
import { ServerGameEngine } from "../server-game-engine";
import {
  GameAction,
  GameState,
  GameCard,
} from "@/app/protected/play/game-engine/types";
import { Database } from "@/types/database.types";
import { GameMode } from "@/app/protected/play/game-modes/types";
import { NextResponse } from "next/server";
import { validateGameAction, validateGameState } from "../validate-game-action";
import { SupabaseClient } from "@supabase/supabase-js";

export async function POST(request: Request) {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const { action, gameId, payload } = await request.json();

    switch (action) {
      case "CREATE_GAME": {
        const { player1Cards, player2Cards, mode } = payload;

        // Validate cards belong to players (skip validation in practice mode)
        const validationResult = await validateGameCards(
          supabase,
          user.id,
          player1Cards,
          player2Cards,
          mode
        );
        if (!validationResult.success) {
          return NextResponse.json(
            { error: validationResult.error },
            { status: 400 }
          );
        }

        // Validate deck sizes
        if (!player1Cards?.length || !player2Cards?.length) {
          return NextResponse.json(
            { error: "Invalid deck size" },
            { status: 400 }
          );
        }

        if (player1Cards.length !== player2Cards.length) {
          return NextResponse.json(
            { error: "Deck sizes must match" },
            { status: 400 }
          );
        }

        // Create new server-side game instance
        const gameEngine = new ServerGameEngine(player1Cards, player2Cards);
        const initialState = gameEngine.getGameState();

        // Create game record in database
        // Serialize game state to JSON-compatible format
        const serializedState = JSON.parse(JSON.stringify(initialState));

        let insertData: Database["public"]["Tables"]["active_games"]["Insert"] =
          {
            player1_id: user.id,
            player2_id:
              mode === "practice" ? user.id : payload.player2Id || user.id,
            status: "in_progress",
            game_state: serializedState,
            player1_deck_id: payload.player1DeckId,
            player2_deck_id: payload.player2DeckId,
          };

        const { data: game, error: createError } = await supabase
          .from("active_games")
          .insert(insertData)
          .select()
          .single();

        if (createError) {
          console.error("Error creating game:", createError);
          return NextResponse.json(
            { error: "Failed to create game" },
            { status: 500 }
          );
        }

        // Return the auto-generated game ID from Supabase
        return NextResponse.json({
          gameId: game.id, // UUID automatically generated by Supabase
          state: initialState,
        });
      }

      case "PROCESS_TURN": {
        // Get game from database
        const { data: game, error: fetchError } = await supabase
          .from("active_games")
          .select("*")
          .eq("id", gameId)
          .single();

        if (fetchError || !game) {
          console.error("Error fetching game:", fetchError);
          return NextResponse.json(
            { error: "Game not found" },
            { status: 404 }
          );
        }

        // Initialize game engine with stored state
        const currentState = game.game_state as GameState;
        console.log("[GameEngine] Retrieved game state:", currentState);

        const gameEngine = new ServerGameEngine([], [], currentState);
        const stateValidation = validateGameState(currentState);
        if (!stateValidation.isValid) {
          return NextResponse.json(
            { error: stateValidation.error },
            { status: 400 }
          );
        }

        // Process the action without validation in practice mode
        const mode = payload.mode as GameMode;
        console.log("[GameEngine] Processing action for mode:", mode);

        if (mode !== "practice") {
          const actionValidation = validateGameAction(
            payload,
            currentState,
            true
          );
          if (!actionValidation.isValid) {
            return NextResponse.json(
              { error: actionValidation.error },
              { status: 400 }
            );
          }
        }

        // Process the action
        const actionResult = gameEngine.processAction(payload);
        if (!actionResult.success) {
          return NextResponse.json(
            { error: actionResult.error },
            { status: 400 }
          );
        }

        const newState = gameEngine.getGameState();

        // If game is over, update status
        if (newState.winner !== null) {
          console.log(
            "[GameEngine] Game completed with winner:",
            newState.winner
          );
          const { error: updateError } = await supabase
            .from("active_games")
            .update({
              status: "completed",
              winner_id: user.id, // For practice mode
              game_state: JSON.parse(JSON.stringify(newState)),
            })
            .eq("id", gameId);

          if (updateError) {
            console.error(
              "[GameEngine] Error updating completed game:",
              updateError
            );
          }
        } else {
          // Update game state
          const { error: updateError } = await supabase
            .from("active_games")
            .update({ game_state: JSON.parse(JSON.stringify(newState)) })
            .eq("id", gameId);

          if (updateError) {
            console.error(
              "[GameEngine] Error updating game state:",
              updateError
            );
          }
        }

        return NextResponse.json({
          result: actionResult,
          state: newState,
        });
      }

      case "START_AUTO_PROCESSING": {
        // Get game from database
        const { data: game, error: fetchError } = await supabase
          .from("active_games")
          .select("*")
          .eq("id", gameId)
          .single();

        if (fetchError || !game) {
          console.error("Error fetching game:", fetchError);
          return NextResponse.json(
            { error: "Game not found" },
            { status: 404 }
          );
        }

        // Start automatic turn processing in the background
        const currentState = game.game_state as GameState;
        const gameEngine = new ServerGameEngine([], [], currentState);

        // Process turns with proper timing and state management
        const processGameTurns = async () => {
          let gameState = currentState;
          let lastActionTime = Date.now();
          const TURN_INTERVAL = 2000; // 2 seconds between turns for better visibility

          while (!gameState.winner) {
            const now = Date.now();
            const timeSinceLastAction = now - lastActionTime;

            // Ensure minimum time between actions
            if (timeSinceLastAction < TURN_INTERVAL) {
              await new Promise(resolve => 
                setTimeout(resolve, TURN_INTERVAL - timeSinceLastAction)
              );
            }

            // Process turn
            const actionResult = gameEngine.processAction({
              type: "END_TURN",
              payload: {} // Empty payload for END_TURN
            });

            if (!actionResult.success) {
              console.error(
                "[GameEngine] Error processing turn:",
                actionResult.error
              );
              break;
            }

            gameState = gameEngine.getGameState();
            lastActionTime = Date.now();

            // Ensure battle log is included in state update
            const serializedState = JSON.parse(JSON.stringify(gameState));
            
            // Update game state in database
            const { error: updateError } = await supabase
              .from("active_games")
              .update({
                game_state: serializedState,
                status: gameState.winner ? "completed" : "in_progress",
                winner_id: gameState.winner ? user.id : null,
              })
              .eq("id", gameId);

            if (updateError) {
              console.error("[GameEngine] Error updating game state:", updateError);
              break;
            }
          }
        };

        // Start processing turns (non-blocking)
        processGameTurns().catch(console.error);

        return NextResponse.json({ success: true });
      }

      case "END_GAME": {
        // First verify the game exists and user has permission
        const { data: game, error: fetchError } = await supabase
          .from("active_games")
          .select("*")
          .eq("id", gameId)
          .single();

        if (fetchError || !game) {
          console.error("Error fetching game:", fetchError);
          return NextResponse.json(
            { error: "Game not found" },
            { status: 404 }
          );
        }

        // Verify user has permission to end this game
        if (game.player1_id !== user.id && game.player2_id !== user.id) {
          return NextResponse.json(
            { error: "Unauthorized to end this game" },
            { status: 403 }
          );
        }

        // Only end games that aren't already completed
        if (game.status !== "completed") {
          const { error: updateError } = await supabase
            .from("active_games")
            .update({
              status: "completed",
              game_state: null, // Clear state to save space
              winner_id: payload.winnerId || null, // Allow specifying winner on game end
            })
            .eq("id", gameId);

          if (updateError) {
            console.error("Error ending game:", updateError);
            return NextResponse.json(
              { error: "Failed to end game" },
              { status: 500 }
            );
          }
        }

        return NextResponse.json({ success: true });
      }

      default:
        return NextResponse.json({ error: "Invalid action" }, { status: 400 });
    }
  } catch (error) {
    console.error("Game engine error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper functions
async function validateGameCards(
  supabase: SupabaseClient<Database, "public", Database["public"]>,
  userId: string,
  player1Cards: GameCard[],
  player2Cards: GameCard[],
  mode: GameMode
) {
  // Skip validation in practice mode
  if (mode === "practice") {
    return { success: true };
  }

  try {
    // Get all cards that should belong to the players
    const { data: userCards, error } = await supabase
      .from("cards")
      .select("id, user_id")
      .in("id", [...player1Cards.map((c) => c.id)]);

    if (error) throw error;

    if (!userCards) {
      return { success: false, error: "Failed to fetch cards" };
    }

    // Only validate player 1's cards in multiplayer
    const player1Valid = player1Cards.every((card) =>
      userCards.some(
        (userCard) => userCard.id === card.id && userCard.user_id === userId
      )
    );

    if (!player1Valid) {
      return { success: false, error: "Invalid cards in deck" };
    }

    return { success: true };
  } catch (error) {
    console.error("Card validation error:", error);
    return { success: false, error: "Failed to validate cards" };
  }
}
