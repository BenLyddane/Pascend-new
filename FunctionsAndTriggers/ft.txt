complete_database_export
#NAME?
#NAME?
#NAME?
#NAME?
#NAME?
#NAME?
#NAME?
#NAME?
#NAME?
#NAME?
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: card_effect_values_update on card_effect_values\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION update_card_special_effects()()\nRETURNS trigger AS $$\n
\nBEGIN
\n    -- Update the special_effects column in cards
\n    UPDATE cards 
\n    SET special_effects = get_card_effects(NEW.card_id)
\n    WHERE id = NEW.card_id;
\n    
\n    RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS card_effect_values_update ON card_effect_values;\nCREATE TRIGGER card_effect_values_update\nAFTER DELETE OR INSERT OR UPDATE\nON card_effect_values\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION update_card_special_effects()();\n"
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: check_game_state_version_trigger on active_games\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION check_game_state_version()()\nRETURNS trigger AS $$\n
\nBEGIN
\n  -- Only check version if game_state is being updated
\n  IF NEW.game_state IS NOT NULL AND OLD.game_state IS NOT NULL THEN
\n    -- Extract version from game_state
\n    IF (NEW.game_state->>'version')::int <= (OLD.game_state->>'version')::int THEN
\n      RAISE EXCEPTION 'version_conflict';
\n    END IF;
\n  END IF;
\n  RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS check_game_state_version_trigger ON active_games;\nCREATE TRIGGER check_game_state_version_trigger\nBEFORE UPDATE\nON active_games\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION check_game_state_version()();\n"
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: log_token_transaction on token_transactions\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION log_token_transaction()()\nRETURNS trigger AS $$\n
\nbegin
\n    raise log 'New token transaction: %', row_to_json(NEW);
\n    return NEW;
\nend;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS log_token_transaction ON token_transactions;\nCREATE TRIGGER log_token_transaction\nBEFORE INSERT\nON token_transactions\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION log_token_transaction()();\n"
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: update_active_games_timestamp on active_games\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION update_timestamp()()\nRETURNS trigger AS $$\n
\nbegin
\n    SET search_path = public, pg_temp;
\n    new.updated_at = now();
\n    return new;
\nend;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS update_active_games_timestamp ON active_games;\nCREATE TRIGGER update_active_games_timestamp\nBEFORE UPDATE\nON active_games\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION update_timestamp()();\n"
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: update_matchmaking_queue_timestamp on matchmaking_queue\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION update_timestamp()()\nRETURNS trigger AS $$\n
\nbegin
\n    SET search_path = public, pg_temp;
\n    new.updated_at = now();
\n    return new;
\nend;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS update_matchmaking_queue_timestamp ON matchmaking_queue;\nCREATE TRIGGER update_matchmaking_queue_timestamp\nBEFORE UPDATE\nON matchmaking_queue\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION update_timestamp()();\n"
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: update_token_balance on token_transactions\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION check_token_balance()()\nRETURNS trigger AS $$\n
\nbegin
\n    -- Add debug logging
\n    raise log 'Token balance trigger executing for user % with amount % and type %', 
\n              NEW.user_id, NEW.amount, NEW.transaction_type;
\n
\n    -- For purchases (amount > 0)
\n    if NEW.transaction_type = 'purchase' then
\n        raise log 'Processing purchase transaction';
\n        
\n        -- Purchases always update purchased_tokens
\n        update player_profiles
\n        set purchased_tokens = purchased_tokens + NEW.amount
\n        where user_id = NEW.user_id;
\n        
\n        raise log 'Updated purchased_tokens for user %', NEW.user_id;
\n    end if;
\n
\n    return NEW;
\nexception
\n    when others then
\n        raise log 'Error in check_token_balance: %', SQLERRM;
\n        raise;
\nend;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS update_token_balance ON token_transactions;\nCREATE TRIGGER update_token_balance\nAFTER INSERT\nON token_transactions\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION check_token_balance()();\n"
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: validate_card_effect_values on card_effect_values\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION validate_card_effect_values()()\nRETURNS trigger AS $$\n
\nDECLARE
\n    card_rarity text;
\nBEGIN
\n    -- Get the card's rarity
\n    SELECT rarity INTO card_rarity
\n    FROM cards
\n    WHERE id = NEW.card_id;
\n
\n    -- Validate the effect is allowed for this rarity
\n    IF NOT EXISTS (
\n        SELECT 1
\n        FROM special_properties sp
\n        WHERE sp.id = NEW.property_id
\n        AND card_rarity = ANY(sp.allowed_rarities)
\n    ) THEN
\n        RAISE EXCEPTION 'Effect not allowed for card rarity %', card_rarity;
\n    END IF;
\n
\n    RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS validate_card_effect_values ON card_effect_values;\nCREATE TRIGGER validate_card_effect_values\nBEFORE INSERT OR UPDATE\nON card_effect_values\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION validate_card_effect_values()();\n"
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: validate_card_properties_trigger on cards\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION validate_card_properties()()\nRETURNS trigger AS $$\n
\nBEGIN
\n  -- Ensure power and health are within reasonable bounds
\n  IF NEW.power < 0 OR NEW.power > 999 OR
\n     NEW.health < 1 OR NEW.health > 999 THEN
\n    RAISE EXCEPTION 'Invalid card properties: power and health must be within reasonable bounds';
\n  END IF;
\n
\n  -- Validate special effects format
\n  IF NEW.special_effects IS NOT NULL AND 
\n     jsonb_typeof(NEW.special_effects::jsonb) != 'array' THEN
\n    RAISE EXCEPTION 'Invalid special effects format';
\n  END IF;
\n
\n  RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS validate_card_properties_trigger ON cards;\nCREATE TRIGGER validate_card_properties_trigger\nBEFORE INSERT OR UPDATE\nON cards\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION validate_card_properties()();\n"
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: validate_deck_cards_trigger on player_decks\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION validate_deck_cards()()\nRETURNS trigger AS $$\n
\nDECLARE
\n  card_id text;
\n  card_count integer;
\nBEGIN
\n  -- Check each card in the deck belongs to the user
\n  FOR card_id IN SELECT jsonb_array_elements(NEW.card_list::jsonb)->>'id'
\n  LOOP
\n    SELECT COUNT(*) INTO card_count
\n    FROM public.cards
\n    WHERE id = card_id::uuid
\n    AND user_id = NEW.user_id
\n    AND is_active = true;
\n
\n    IF card_count = 0 THEN
\n      RAISE EXCEPTION 'Invalid card in deck: %', card_id;
\n    END IF;
\n  END LOOP;
\n
\n  RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS validate_deck_cards_trigger ON player_decks;\nCREATE TRIGGER validate_deck_cards_trigger\nBEFORE INSERT OR UPDATE\nON player_decks\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION validate_deck_cards()();\n"
"\n-- TRIGGER DEFINITIONS:\n-- Trigger: validate_matchmaking_entry_trigger on matchmaking_queue\nCREATE OR REPLACE FUNCTION EXECUTE FUNCTION validate_matchmaking_entry()()\nRETURNS trigger AS $$\n
\nBEGIN
\n  -- Ensure user isn't already in queue
\n  IF EXISTS (
\n    SELECT 1 FROM public.matchmaking_queue
\n    WHERE user_id = NEW.user_id
\n    AND status = 'waiting'
\n    AND id != NEW.id
\n  ) THEN
\n    RAISE EXCEPTION 'User already in matchmaking queue';
\n  END IF;
\n
\n  -- Validate deck exists and belongs to user
\n  IF NOT EXISTS (
\n    SELECT 1 FROM public.player_decks
\n    WHERE id = NEW.deck_id::uuid
\n    AND user_id = NEW.user_id
\n    AND is_active = true
\n  ) THEN
\n    RAISE EXCEPTION 'Invalid deck for matchmaking';
\n  END IF;
\n
\n  RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS validate_matchmaking_entry_trigger ON matchmaking_queue;\nCREATE TRIGGER validate_matchmaking_entry_trigger\nBEFORE INSERT OR UPDATE\nON matchmaking_queue\nFOR EACH ROW\nEXECUTE FUNCTION EXECUTE FUNCTION validate_matchmaking_entry()();\n"
"\n-- Function: handle_new_stripe_user\nCREATE OR REPLACE FUNCTION public.handle_new_stripe_user()\nRETURNS trigger\nAS $$\n
\n  begin
\n    insert into public.users (id, full_name, avatar_url)
\n    values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
\n    return new;
\n  end;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: handle_new_user\nCREATE OR REPLACE FUNCTION public.handle_new_user()\nRETURNS trigger\nAS $$\n
\nBEGIN
\n  -- Insert the player profile
\n  INSERT INTO public.player_profiles (
\n    user_id,
\n    rank_points,
\n    rank_tier,
\n    seasonal_rank_points,
\n    season_highest_rank,
\n    total_matches,
\n    wins,
\n    losses,
\n    draws,
\n    current_streak,
\n    longest_streak,
\n    settings,
\n    free_tokens,
\n    purchased_tokens
\n  ) VALUES (
\n    NEW.id,
\n    1000,
\n    'bronze',
\n    0,
\n    1000,
\n    0,
\n    0,
\n    0,
\n    0,
\n    0,
\n    0,
\n    '{}',
\n    10,
\n    0
\n  );
\n  
\n  RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: get_valid_properties_for_rarity\nCREATE OR REPLACE FUNCTION public.get_valid_properties_for_rarity(card_rarity text)\nRETURNS TABLE(property_id uuid)\nAS $$\n
\nBEGIN
\n    RETURN QUERY
\n    SELECT sp.id
\n    FROM special_properties sp
\n    WHERE card_rarity = ANY(sp.allowed_rarities);
\nEND;
\n\n$$ LANGUAGE plpgsql;\n"
"\n-- Function: calculate_card_mana_modifier\nCREATE OR REPLACE FUNCTION public.calculate_card_mana_modifier(card_id uuid)\nRETURNS integer\nAS $$\n
\nDECLARE
\n    total_modifier integer := 0;
\nBEGIN
\n    SELECT COALESCE(SUM(sp.power_level * cev.value), 0)
\n    INTO total_modifier
\n    FROM card_effect_values cev
\n    JOIN special_properties sp ON sp.id = cev.property_id
\n    WHERE cev.card_id = $1;
\n
\n    RETURN total_modifier;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n"
"\n-- Function: create_trade_listing\nCREATE OR REPLACE FUNCTION public.create_trade_listing(p_card_id uuid, p_seller_id uuid, p_token_price integer)\nRETURNS uuid\nAS $$\n
\ndeclare
\n  v_listing_id uuid;
\nbegin
\n  -- Delete any cancelled listings for this card
\n  delete from trade_listings
\n  where card_id = p_card_id
\n  and seller_id = p_seller_id
\n  and status = 'cancelled';
\n
\n  -- Check if card is already actively listed
\n  if exists (
\n    select 1
\n    from trade_listings
\n    where card_id = p_card_id
\n    and status = 'active'
\n  ) then
\n    raise exception 'Card is already listed for trade';
\n  end if;
\n
\n  -- Create new listing
\n  insert into trade_listings (
\n    card_id,
\n    seller_id,
\n    token_price,
\n    status,
\n    listed_at
\n  ) values (
\n    p_card_id,
\n    p_seller_id,
\n    p_token_price,
\n    'active',
\n    now()
\n  )
\n  returning id into v_listing_id;
\n
\n  return v_listing_id;
\nend;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: purchase_trade_listing\nCREATE OR REPLACE FUNCTION public.purchase_trade_listing(p_listing_id uuid, p_buyer_id uuid, p_use_purchased_tokens boolean DEFAULT false)\nRETURNS void\nAS $$\n
\ndeclare
\n    v_token_price integer;
\n    v_seller_id uuid;
\n    v_card_id uuid;
\nbegin
\n    -- Get listing details and lock the row
\n    select token_price, seller_id, card_id
\n    into v_token_price, v_seller_id, v_card_id
\n    from trade_listings
\n    where id = p_listing_id
\n    and status = 'active'
\n    for update;
\n
\n    -- Check if listing exists and is active
\n    if not found then
\n        raise exception 'Listing not found or is not active';
\n    end if;
\n
\n    -- Check if buyer has enough tokens
\n    if p_use_purchased_tokens then
\n        if not exists (
\n            select 1
\n            from player_profiles
\n            where user_id = p_buyer_id
\n            and purchased_tokens >= v_token_price
\n        ) then
\n            raise exception 'Insufficient purchased tokens';
\n        end if;
\n    else
\n        if not exists (
\n            select 1
\n            from player_profiles
\n            where user_id = p_buyer_id
\n            and free_tokens >= v_token_price
\n        ) then
\n            raise exception 'Insufficient tokens';
\n        end if;
\n    end if;
\n
\n    -- Begin transaction
\n    -- 1. Deduct tokens from buyer
\n    if p_use_purchased_tokens then
\n        update player_profiles
\n        set purchased_tokens = purchased_tokens - v_token_price
\n        where user_id = p_buyer_id;
\n    else
\n        update player_profiles
\n        set free_tokens = free_tokens - v_token_price
\n        where user_id = p_buyer_id;
\n    end if;
\n
\n    -- 2. Add tokens to seller (minus 1 token fee)
\n    update player_profiles
\n    set free_tokens = free_tokens + (v_token_price - 1)
\n    where user_id = v_seller_id;
\n
\n    -- 3. Transfer card ownership
\n    update cards
\n    set user_id = p_buyer_id
\n    where id = v_card_id;
\n
\n    -- 4. Update listing status
\n    update trade_listings
\n    set status = 'sold'
\n    where id = p_listing_id;
\n
\n    -- Create transaction records
\n    insert into token_transactions (
\n        user_id,
\n        amount,
\n        transaction_type,
\n        is_purchased,
\n        description
\n    ) values
\n    (p_buyer_id, -v_token_price, 'trade_purchase', p_use_purchased_tokens, 'Card purchase from marketplace'),
\n    (v_seller_id, v_token_price - 1, 'trade_sale', false, 'Card sold on marketplace (1 token fee)');
\nend;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: check_game_state_version\nCREATE OR REPLACE FUNCTION public.check_game_state_version()\nRETURNS trigger\nAS $$\n
\nBEGIN
\n  -- Only check version if game_state is being updated
\n  IF NEW.game_state IS NOT NULL AND OLD.game_state IS NOT NULL THEN
\n    -- Extract version from game_state
\n    IF (NEW.game_state->>'version')::int <= (OLD.game_state->>'version')::int THEN
\n      RAISE EXCEPTION 'version_conflict';
\n    END IF;
\n  END IF;
\n  RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n"
"\n-- Function: get_card_effects\nCREATE OR REPLACE FUNCTION public.get_card_effects(p_card_id uuid)\nRETURNS jsonb\nAS $$\n
\nBEGIN
\n    RETURN (
\n        SELECT jsonb_agg(
\n            jsonb_build_object(
\n                'name', sp.name,
\n                'description', sp.description,
\n                'effect_type', sp.effect_type,
\n                'effect_icon', sp.effect_icon,
\n                'value', cev.value,
\n                'power_level', sp.power_level,
\n                'combo_tags', sp.combo_tags
\n            )
\n        )
\n        FROM card_effect_values cev
\n        JOIN special_properties sp ON sp.id = cev.property_id
\n        WHERE cev.card_id = p_card_id
\n    );
\nEND;
\n\n$$ LANGUAGE plpgsql;\n"
"\n-- Function: update_card_special_effects\nCREATE OR REPLACE FUNCTION public.update_card_special_effects()\nRETURNS trigger\nAS $$\n
\nBEGIN
\n    -- Update the special_effects column in cards
\n    UPDATE cards 
\n    SET special_effects = get_card_effects(NEW.card_id)
\n    WHERE id = NEW.card_id;
\n    
\n    RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n"
"\n-- Function: validate_card_effect_values\nCREATE OR REPLACE FUNCTION public.validate_card_effect_values()\nRETURNS trigger\nAS $$\n
\nDECLARE
\n    card_rarity text;
\nBEGIN
\n    -- Get the card's rarity
\n    SELECT rarity INTO card_rarity
\n    FROM cards
\n    WHERE id = NEW.card_id;
\n
\n    -- Validate the effect is allowed for this rarity
\n    IF NOT EXISTS (
\n        SELECT 1
\n        FROM special_properties sp
\n        WHERE sp.id = NEW.property_id
\n        AND card_rarity = ANY(sp.allowed_rarities)
\n    ) THEN
\n        RAISE EXCEPTION 'Effect not allowed for card rarity %', card_rarity;
\n    END IF;
\n
\n    RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n"
"\n-- Function: get_effect_value\nCREATE OR REPLACE FUNCTION public.get_effect_value(effect_data jsonb)\nRETURNS integer\nAS $$\n
\nBEGIN
\n    -- Try to get value as integer first
\n    BEGIN
\n        RETURN (effect_data->>'value')::integer;
\n    EXCEPTION WHEN OTHERS THEN
\n        -- If that fails, return 0
\n        RETURN 0;
\n    END;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n"
"\n-- Function: match_players\nCREATE OR REPLACE FUNCTION public.match_players(player1_id uuid, player2_id uuid)\nRETURNS void\nAS $$\n
\ndeclare
\n    player1_entry record;
\n    player2_entry record;
\nbegin
\n    SET search_path = public, pg_temp;
\n    
\n    -- Get both players' queue entries
\n    select * into player1_entry from matchmaking_queue where id = player1_id for update;
\n    select * into player2_entry from matchmaking_queue where id = player2_id for update;
\n    
\n    -- Verify both entries exist and are waiting
\n    if player1_entry.status != 'waiting' or player2_entry.status != 'waiting' then
\n        raise exception 'One or both players are no longer available for matching';
\n    end if;
\n    
\n    -- Update both entries to matched status
\n    update matchmaking_queue
\n    set status = 'matched',
\n        opponent_deck_id = player2_entry.deck_id,
\n        updated_at = now()
\n    where id = player1_id;
\n    
\n    update matchmaking_queue
\n    set status = 'matched',
\n        opponent_deck_id = player1_entry.deck_id,
\n        updated_at = now()
\n    where id = player2_id;
\n    
\n    -- Create active game
\n    insert into active_games (
\n        player1_id,
\n        player2_id,
\n        player1_deck_id,
\n        player2_deck_id
\n    ) values (
\n        player1_entry.user_id,
\n        player2_entry.user_id,
\n        player1_entry.deck_id,
\n        player2_entry.deck_id
\n    );
\nend;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: begin_transaction\nCREATE OR REPLACE FUNCTION public.begin_transaction()\nRETURNS void\nAS $$\n
\nbegin
\n    SET search_path = public, pg_temp;
\n    -- Start a new transaction
\n    -- This is implicit in Postgres but we include it for clarity
\nend;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: commit_transaction\nCREATE OR REPLACE FUNCTION public.commit_transaction()\nRETURNS void\nAS $$\n
\nbegin
\n    SET search_path = public, pg_temp;
\n    -- Commit the current transaction
\n    commit;
\nend;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: rollback_transaction\nCREATE OR REPLACE FUNCTION public.rollback_transaction()\nRETURNS void\nAS $$\n
\nbegin
\n    SET search_path = public, pg_temp;
\n    -- Rollback the current transaction
\n    rollback;
\nend;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: validate_card_properties\nCREATE OR REPLACE FUNCTION public.validate_card_properties()\nRETURNS trigger\nAS $$\n
\nBEGIN
\n  -- Ensure power and health are within reasonable bounds
\n  IF NEW.power < 0 OR NEW.power > 999 OR
\n     NEW.health < 1 OR NEW.health > 999 THEN
\n    RAISE EXCEPTION 'Invalid card properties: power and health must be within reasonable bounds';
\n  END IF;
\n
\n  -- Validate special effects format
\n  IF NEW.special_effects IS NOT NULL AND 
\n     jsonb_typeof(NEW.special_effects::jsonb) != 'array' THEN
\n    RAISE EXCEPTION 'Invalid special effects format';
\n  END IF;
\n
\n  RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql;\n"
"\n-- Function: validate_deck_cards\nCREATE OR REPLACE FUNCTION public.validate_deck_cards()\nRETURNS trigger\nAS $$\n
\nDECLARE
\n  card_id text;
\n  card_count integer;
\nBEGIN
\n  -- Check each card in the deck belongs to the user
\n  FOR card_id IN SELECT jsonb_array_elements(NEW.card_list::jsonb)->>'id'
\n  LOOP
\n    SELECT COUNT(*) INTO card_count
\n    FROM public.cards
\n    WHERE id = card_id::uuid
\n    AND user_id = NEW.user_id
\n    AND is_active = true;
\n
\n    IF card_count = 0 THEN
\n      RAISE EXCEPTION 'Invalid card in deck: %', card_id;
\n    END IF;
\n  END LOOP;
\n
\n  RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: update_timestamp\nCREATE OR REPLACE FUNCTION public.update_timestamp()\nRETURNS trigger\nAS $$\n
\nbegin
\n    SET search_path = public, pg_temp;
\n    new.updated_at = now();
\n    return new;
\nend;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: validate_matchmaking_entry\nCREATE OR REPLACE FUNCTION public.validate_matchmaking_entry()\nRETURNS trigger\nAS $$\n
\nBEGIN
\n  -- Ensure user isn't already in queue
\n  IF EXISTS (
\n    SELECT 1 FROM public.matchmaking_queue
\n    WHERE user_id = NEW.user_id
\n    AND status = 'waiting'
\n    AND id != NEW.id
\n  ) THEN
\n    RAISE EXCEPTION 'User already in matchmaking queue';
\n  END IF;
\n
\n  -- Validate deck exists and belongs to user
\n  IF NOT EXISTS (
\n    SELECT 1 FROM public.player_decks
\n    WHERE id = NEW.deck_id::uuid
\n    AND user_id = NEW.user_id
\n    AND is_active = true
\n  ) THEN
\n    RAISE EXCEPTION 'Invalid deck for matchmaking';
\n  END IF;
\n
\n  RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: check_token_balance\nCREATE OR REPLACE FUNCTION public.check_token_balance()\nRETURNS trigger\nAS $$\n
\nbegin
\n    -- Add debug logging
\n    raise log 'Token balance trigger executing for user % with amount % and type %', 
\n              NEW.user_id, NEW.amount, NEW.transaction_type;
\n
\n    -- For purchases (amount > 0)
\n    if NEW.transaction_type = 'purchase' then
\n        raise log 'Processing purchase transaction';
\n        
\n        -- Purchases always update purchased_tokens
\n        update player_profiles
\n        set purchased_tokens = purchased_tokens + NEW.amount
\n        where user_id = NEW.user_id;
\n        
\n        raise log 'Updated purchased_tokens for user %', NEW.user_id;
\n    end if;
\n
\n    return NEW;
\nexception
\n    when others then
\n        raise log 'Error in check_token_balance: %', SQLERRM;
\n        raise;
\nend;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: log_token_transaction\nCREATE OR REPLACE FUNCTION public.log_token_transaction()\nRETURNS trigger\nAS $$\n
\nbegin
\n    raise log 'New token transaction: %', row_to_json(NEW);
\n    return NEW;
\nend;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: update_collection_stats\nCREATE OR REPLACE FUNCTION public.update_collection_stats()\nRETURNS trigger\nAS $$\n
\nBEGIN
\n    INSERT INTO public.collection_stats (
\n        user_id,
\n        total_cards,
\n        unique_cards,
\n        legendary_count,
\n        epic_count,
\n        rare_count,
\n        common_count,
\n        last_updated_at
\n    )
\n    VALUES (
\n        NEW.user_id,
\n        (SELECT COALESCE(SUM(quantity), 0) FROM public.player_cards WHERE user_id = NEW.user_id),
\n        (SELECT COUNT(DISTINCT card_id) FROM public.player_cards WHERE user_id = NEW.user_id),
\n        (SELECT COUNT(*) FROM public.player_cards pc 
\n         JOIN public.cards c ON pc.card_id = c.id 
\n         WHERE pc.user_id = NEW.user_id AND c.rarity = 'legendary'),
\n        (SELECT COUNT(*) FROM public.player_cards pc 
\n         JOIN public.cards c ON pc.card_id = c.id 
\n         WHERE pc.user_id = NEW.user_id AND c.rarity = 'epic'),
\n        (SELECT COUNT(*) FROM public.player_cards pc 
\n         JOIN public.cards c ON pc.card_id = c.id 
\n         WHERE pc.user_id = NEW.user_id AND c.rarity = 'rare'),
\n        (SELECT COUNT(*) FROM public.player_cards pc 
\n         JOIN public.cards c ON pc.card_id = c.id 
\n         WHERE pc.user_id = NEW.user_id AND c.rarity = 'common'),
\n        NOW()
\n    )
\n    ON CONFLICT (user_id) DO UPDATE
\n    SET
\n        total_cards = EXCLUDED.total_cards,
\n        unique_cards = EXCLUDED.unique_cards,
\n        legendary_count = EXCLUDED.legendary_count,
\n        epic_count = EXCLUDED.epic_count,
\n        rare_count = EXCLUDED.rare_count,
\n        common_count = EXCLUDED.common_count,
\n        last_updated_at = EXCLUDED.last_updated_at;
\n    
\n    RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: update_player_ranks\nCREATE OR REPLACE FUNCTION public.update_player_ranks()\nRETURNS trigger\nAS $$\n
\nBEGIN
\n    -- Update winner
\n    UPDATE public.player_profiles
\n    SET 
\n        rank_points = rank_points + NEW.points_exchanged,
\n        wins = wins + 1,
\n        total_matches = total_matches + 1,
\n        current_streak = CASE 
\n            WHEN user_id = NEW.winner_id THEN current_streak + 1
\n            ELSE 0
\n        END,
\n        longest_streak = CASE 
\n            WHEN user_id = NEW.winner_id AND current_streak + 1 > longest_streak THEN current_streak + 1
\n            ELSE longest_streak
\n        END,
\n        last_match_at = NEW.ended_at
\n    WHERE user_id = NEW.winner_id;
\n
\n    -- Update loser
\n    UPDATE public.player_profiles
\n    SET 
\n        rank_points = rank_points - NEW.points_exchanged,
\n        losses = losses + 1,
\n        total_matches = total_matches + 1,
\n        current_streak = 0,
\n        last_match_at = NEW.ended_at
\n    WHERE user_id = CASE 
\n        WHEN NEW.player1_id = NEW.winner_id THEN NEW.player2_id
\n        ELSE NEW.player1_id
\n    END;
\n
\n    RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: check_turn_timeout\nCREATE OR REPLACE FUNCTION public.check_turn_timeout()\nRETURNS trigger\nAS $$\n
\nBEGIN
\n    -- If turn has exceeded 45 seconds, auto-end it
\n    IF (NEW.status = 'in_progress' AND 
\n        EXTRACT(EPOCH FROM (NOW() - NEW.turn_start_time)) > 45) THEN
\n        
\n        -- Insert an auto-end-turn action
\n        INSERT INTO public.game_actions 
\n            (game_id, player_id, action_type, action_data)
\n        VALUES 
\n            (NEW.id, NEW.current_turn, 'end_turn', '{""auto"": true}'::jsonb);
\n            
\n        -- Update turn information
\n        NEW.current_turn := CASE 
\n            WHEN NEW.current_turn = NEW.player1_id THEN NEW.player2_id
\n            ELSE NEW.player1_id
\n        END;
\n        NEW.turn_number := NEW.turn_number + 1;
\n        NEW.turn_start_time := NOW();
\n    END IF;
\n    
\n    RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
"\n-- Function: process_matchmaking\nCREATE OR REPLACE FUNCTION public.process_matchmaking()\nRETURNS trigger\nAS $$\n
\nDECLARE
\n    matching_player_record RECORD;
\n    new_game_id uuid;
\nBEGIN
\n    -- Find a matching player within rank range
\n    SELECT * INTO matching_player_record
\n    FROM public.matchmaking_queue
\n    WHERE user_id != NEW.user_id
\n    AND status = 'searching'
\n    AND ABS(rank_points - NEW.rank_points) <= 
\n        (NEW.match_preferences->>'rank_range')::integer
\n    AND joined_at < NEW.joined_at
\n    ORDER BY joined_at ASC
\n    LIMIT 1;
\n    
\n    IF FOUND THEN
\n        -- Create a new game
\n        INSERT INTO public.active_games (
\n            player1_id,
\n            player2_id,
\n            player1_deck_id,
\n            player2_deck_id,
\n            current_turn,
\n            status
\n        ) VALUES (
\n            matching_player_record.user_id,
\n            NEW.user_id,
\n            matching_player_record.deck_id,
\n            NEW.deck_id,
\n            CASE WHEN random() > 0.5 
\n                THEN matching_player_record.user_id 
\n                ELSE NEW.user_id 
\n            END,
\n            'waiting'
\n        )
\n        RETURNING id INTO new_game_id;
\n        
\n        -- Update both players' queue status
\n        UPDATE public.matchmaking_queue
\n        SET status = 'matched'
\n        WHERE user_id IN (NEW.user_id, matching_player_record.user_id);
\n    END IF;
\n    
\n    RETURN NEW;
\nEND;
\n\n$$ LANGUAGE plpgsql\nSECURITY DEFINER;\n"
\n-- Grants for function: begin_transaction\nGRANT EXECUTE ON FUNCTION public.begin_transaction() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: calculate_card_mana_modifier\nGRANT EXECUTE ON FUNCTION public.calculate_card_mana_modifier(card_id uuid) TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: check_game_state_version\nGRANT EXECUTE ON FUNCTION public.check_game_state_version() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: check_token_balance\nGRANT EXECUTE ON FUNCTION public.check_token_balance() TO anon, authenticated, postgres, service_role;
\n-- Grants for function: check_turn_timeout\nGRANT EXECUTE ON FUNCTION public.check_turn_timeout() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: commit_transaction\nGRANT EXECUTE ON FUNCTION public.commit_transaction() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: create_trade_listing\nGRANT EXECUTE ON FUNCTION public.create_trade_listing(p_card_id uuid, p_seller_id uuid, p_token_price integer) TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: get_card_effects\nGRANT EXECUTE ON FUNCTION public.get_card_effects(p_card_id uuid) TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: get_effect_value\nGRANT EXECUTE ON FUNCTION public.get_effect_value(effect_data jsonb) TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: get_valid_properties_for_rarity\nGRANT EXECUTE ON FUNCTION public.get_valid_properties_for_rarity(card_rarity text) TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: handle_new_stripe_user\nGRANT EXECUTE ON FUNCTION public.handle_new_stripe_user() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: handle_new_user\nGRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: log_token_transaction\nGRANT EXECUTE ON FUNCTION public.log_token_transaction() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: match_players\nGRANT EXECUTE ON FUNCTION public.match_players(player1_id uuid, player2_id uuid) TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: process_matchmaking\nGRANT EXECUTE ON FUNCTION public.process_matchmaking() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: purchase_trade_listing\nGRANT EXECUTE ON FUNCTION public.purchase_trade_listing(p_listing_id uuid, p_buyer_id uuid, p_use_purchased_tokens boolean DEFAULT false) TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: rollback_transaction\nGRANT EXECUTE ON FUNCTION public.rollback_transaction() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: update_card_special_effects\nGRANT EXECUTE ON FUNCTION public.update_card_special_effects() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: update_collection_stats\nGRANT EXECUTE ON FUNCTION public.update_collection_stats() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: update_player_ranks\nGRANT EXECUTE ON FUNCTION public.update_player_ranks() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: update_timestamp\nGRANT EXECUTE ON FUNCTION public.update_timestamp() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: validate_card_effect_values\nGRANT EXECUTE ON FUNCTION public.validate_card_effect_values() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: validate_card_properties\nGRANT EXECUTE ON FUNCTION public.validate_card_properties() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: validate_deck_cards\nGRANT EXECUTE ON FUNCTION public.validate_deck_cards() TO PUBLIC, anon, authenticated, postgres, service_role;
\n-- Grants for function: validate_matchmaking_entry\nGRANT EXECUTE ON FUNCTION public.validate_matchmaking_entry() TO PUBLIC, anon, authenticated, postgres, service_role;
